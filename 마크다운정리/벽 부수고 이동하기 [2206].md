# 벽 부수고 이동하기 [2206]

백준 - https://www.acmicpc.net/problem/2206

깃헙 - https://github.com/shs9509/study



### 문제

- N×M의 행렬로 표현되는 맵이 있다.
- 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 
- 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다.
- 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.
- 만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.
- 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.
- 맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.

------



### 입력

- 첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 
- 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. 
- (1, 1)과 (N, M)은 항상 0이라고 가정하자.

### 출력

- 첫째 줄에 최단 거리를 출력한다. 

- 불가능할 때는 -1을 출력한다.

  

![image-20210324235620349](C:\Users\ssej0\AppData\Roaming\Typora\typora-user-images\image-20210324235620349.png)

-----



## 풀이과정

- 그래프, BFS 문제
- 출력 조건이 까다로울 수 있지만 BFS 출력을 생각해보면 어렵진 않다.



```python
def dfs(size,first):    # 사람수, 그래프의 시작지점
    visit = [0 for _ in range(size+1)]
    S=list()
    S.append(first)
    visit[first] = 1
    while S:
        start = S.pop(0)
        for i in direct[start]: 
            if visit[i] == 0:
                S.append(i)
                visit[i] = visit[start] + 1 
                # 방문하면서 start가 가지고있던 친구거리 값을 +1 한다.
    return max(visit)-1

num = int(input())  # 사람수
direct = [[] for _ in range(num+1)] # 연결 그래프
cnt = list()    # 최대 친구 거리수 저장리스트

while True:
    a, b = list(map(int, input().split())) 
    if a == -1:
        break
    direct[a].append(b)
    direct[b].append(a) # 양방향으로 친구를 리스트에 등록한다.


for i in range(1,num+1):    # 각 사람마다 시작지점으로 그래프를 탐색한다.
    cnt.append(dfs(num,i))

min_value = min(cnt)    #  친구 최소거리값
print(min_value,cnt.count(min_value)) # 친구 최소거리값과 그 값을 가진 사람수

for i in range(num):    # 최소값을 가진 사람 출력
    if min_value == cnt[i]:
        print(i+1, end=' ')
```



-------



### 느낀점

- 실력이 늘은건가.. 이 문제가 왜 골드5 문제인지 의아하다.

