# 더하기 사이클 [1110]

백준 - https://www.acmicpc.net/problem/1110



### 문제

-  0보다 크거나 같고, 99보다 작거나 같은 정수가 주어진다. 
-  먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 
-  Example:
   -  26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.
-  N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.



### 입력

- 첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.



### 출력

- 첫째 줄에 N의 사이클 길이를 출력한다.

  

## 풀이과정



- 받는 값의 일의자리 십의 자리를 이용하기 때문에 10으로 나눈 나머지, 몫을 이용하였다.
- `divmod` 를 통해서 복잡한 수식을 걸러냈다.
- while 문을 통해서 반복을 진행해서 값의 일치가 될경우 반복된 값을 return 하도록 한다.



```python
number = input()    
first_number= int(number)   #초기값
count =0    #반복횟수
number= int(number)
while True: #break를 만날때까지 반복

    if(number)>=10:
        (a,b) = divmod(number,10)   #a는 몫 ,b는 나머지
        number = 10*b + ((a+b)%10)
    else:
        number=number*10+number #한자리경우 10으로 나눌 필요가없다.
    count += 1  #반복횟수 증가

    if first_number == number:  #초기값과 같다면 반복을 빠져나온다.
        break
    
print(count)
```



### 느낀점

- 문제를 이해하는데 오래걸렸다. 한자리수의 경우 어떻게 된다는건지 명확하지 않았기 때문

  명세서를 항상 세밀하게 읽어야 한다.

- divmod를 알아야 더 간단하다. 

  ```python
  (a,b) = divmod(10,4)  # a:몫, b:나머지
  ```

- 처음엔 recursive를 생각했었지만 whlie문이 훨씬 쉽다고 생각하여 바꿨다.