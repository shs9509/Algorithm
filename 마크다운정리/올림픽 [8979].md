# 올림픽 [8979]

백준 - https://www.acmicpc.net/problem/8979



### 문제

- 올림픽은 참가에 의의가 있기에 공식적으로는 국가간 순위를 정하지 않는다. 

- 그러나, 많은 사람들이 자신의 국가가 얼마나 잘 하는지에 관심이 많기 때문에 비공식적으로는 국가간 순위를 정하고 있다. 

- 두 나라가 각각 얻은 금, 은, 동메달 수가 주어지면, 보통 다음 규칙을 따라 어느 나라가 더 잘했는지 결정한다.

  1.금메달 수가 더 많은 나라 

  2.금메달 수가 같으면, 은메달 수가 더 많은 나라

  3.금, 은메달 수가 모두 같으면, 동메달 수가 더 많은 나라 

- 각 국가는 1부터 N 사이의 정수로 표현된다. 한 국가의 등수는 (자신보다 더 잘한 나라 수) + 1로 정의된다. 

- 만약 두 나라가 금, 은, 동메달 수가 모두 같다면 두 나라의 등수는 같다. 

  - 예를 들어, 1번 국가가 금메달 1개, 은메달 1개를 얻었고, 2번 국가와 3번 국가가 모두 은메달 1개를 얻었으며, 4번 국가는 메달을 얻지 못하였다면,
  - 1번 국가가 1등, 2번 국가와 3번 국가가 공동 2등, 4번 국가가 4등이 된다.
  - 이 경우 3등은 없다. 

- 각 국가의 금, 은, 동메달 정보를 입력받아서, 어느 국가가 몇 등을 했는지 알려주는 프로그램을 작성하시오. 

- 

### 입력

- 입력의 첫 줄은 국가의 수 N(1 ≤ N ≤ 1,000)과 등수를 알고 싶은 국가 K(1 ≤ K ≤ N)가 빈칸을 사이에 두고 주어진다. 
- 각 국가는 1부터 N 사이의 정수로 표현된다. 
- 이후 N개의 각 줄에는 차례대로 각 국가를 나타내는 정수와 이 국가가 얻은 금, 은, 동메달의 수가 빈칸을 사이에 두고 주어진다. 
- 전체 메달 수의 총합은 1,000,000 이하이다.



### 출력

- 출력은 단 한 줄이며, 입력받은 국가 K의 등수를 하나의 정수로 출력한다.
-  등수는 반드시 문제에서 정의된 방식을 따라야 한다. 

![image-20210224000700423](C:\Users\ssej0\Desktop\알고리즘\마크다운정리\image\image-20210224000700423.png)

## 풀이과정

- 금메달 은메달 동메달 개수를 비교를 하며 정렬할때 버블정렬을 사용했다.
- 국가 금은동 배열 끝에 [등수] 원소를 추가하여 이를 통해 등수를 표현한다.
- 같은 메달수의 경우 등수를 같게 해준다.

```python
a,b = list(map(int, input().split()))
c = list()
for i in range(a):
    c.append(list(map(int, input().split())))

for k in range(len(c)):
    c[k].append(int(k)+1)	# 등수표현

for n in range(len(c)-1):	
    for j in range(len(c)-n-1):
        if c[j][1] < c[j+1][1]:	# 금메달 비교
            c[j][4] ,c[j+1][4] = c[j+1][4], c[j][4]  
            c[j], c[j+1] = c[j+1], c[j]

for n in range(len(c)-1):
    for p in range(len(c)-n-1):
        if c[p][1] == c[p+1][1] and c[p][2] < c[p+1][2]:	# 은메달 비교
            c[p][4] ,c[p+1][4] = c[p+1][4], c[p][4]
            c[p], c[p+1] = c[p+1], c[p]

for n in range(len(c)-1):
    for y in range(len(c)-n-1):   # 동메달 비교     
        if c[y][1] == c[y+1][1] and c[y][2] == c[y+1][2] and c[y][3] < c[y+1][3]: 
            c[y][4] ,c[y+1][4] = c[y+1][4], c[y][4]
            c[y], c[y+1] = c[y+1], c[y]
    
for z in range(len(c)-1):	#값이 같은경우 등수를 높은걸로 통일시켜준다.
    if c[z][1] == c[z+1][1] and c[z][2] == c[z+1][2] and c[z][3] == c[z+1][3]:
        c[z+1][4] = c[z][4]


for f in c:
    if f[0] == b:
        print(f[4])
```



### 느낀점

- 상당히 비효율적으로 보여서 뭉치려고 했으나 오류가 난다.
- for문이 같은 레벨에 있다면 안심하고 같은 변수를 써도된다.
- 비효율 적인거같은데 이것이 최선일까?
- sorted 와 람다를 쓴다면 훨씬~~~~ 쉬워진다. 람다 공부하자.