# 후보 추천하기 [1713]

백준 - https://www.acmicpc.net/problem/1713



### 문제

- 월드초등학교 학생회장 후보는 일정 기간 동안 전체 학생의 추천에 의하여 정해진 수만큼 선정된다. 
- 학교 홈페이지에 추천받은 학생의 사진을 게시할 수 있는 사진틀을 후보의 수만큼 만들었다. 
- 추천받은 학생의 사진을 사진틀에 게시하고 추천받은 횟수를 표시하는 규칙은 다음과 같다.
  1. 학생들이 추천을 시작하기 전에 모든 사진틀은 비어있다.
  2. 어떤 학생이 특정 학생을 추천하면, 추천받은 학생의 사진이 반드시 사진틀에 게시되어야 한다.
  3. 비어있는 사진틀이 없는 경우에는 현재까지 추천 받은 횟수가 가장 적은 학생의 사진을 삭제하고, 그 자리에 새롭게 추천받은 학생의 사진을 게시한다. 이때, 현재까지 추천 받은 횟수가 가장 적은 학생이 두 명 이상일 경우에는 그러한 학생들 중 게시된 지 가장 오래된 사진을 삭제한다.
  4. 현재 사진이 게시된 학생이 다른 학생의 추천을 받은 경우에는 추천받은 횟수만 증가시킨다.
  5. 사진틀에 게시된 사진이 삭제되는 경우에는 해당 학생이 추천받은 횟수는 0으로 바뀐다.

- 후보의 수 즉, 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정하는 프로그램을 작성하시오.

### 입력

- 첫째 줄에는 사진틀의 개수 N이 주어진다. (1≤N≤20) 
- 둘째 줄에는 전체 학생의 총 추천 횟수가 주어지고, 셋째 줄에는 추천받은 학생을 나타내는 번호가 빈 칸을 사이에 두고 추천받은 순서대로 주어진다. 
- 총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수이다.



### 출력

- 사진틀에 사진이 게재된 최종 후보의 학생 번호를 증가하는 순서대로 출력한다.

![image-20210224002409014](C:\Users\ssej0\Desktop\알고리즘\마크다운정리\image\image-20210224002409014.png)

## 풀이과정

- 액자에 사진이 들어가는 경우의 수를 생각해보자

  1. 액자가 꽉차지않았고 액자에 없는 추천이 들어올 경우
  2. 기존 액자에 있는 추천번호가 들어올 경우
  3. 새로운 추천이 들어올 경우

- 액자리스트와 그 추천수를 저장하는 리스트를 활용하였다.

  ex) [2 ,6 ,7] 상황에서 7이 한번더 추천되면 추천리스트는 [1,1,1]  ->  [1,1,2]

- 액자에서 사진을 꺼낼떄 추천저장 리스트를 이용해 골라낸다.

```python
def min_idx(li):
    min_val = 1000
    min_id = 0
    for i in range(len(li)-1,-1,-1):
        if min_val>=li[i]: 
            min_id= i
            min_val =li[i]
    return min_id           #최소값 인덱스구하기


frame_num = int(input()) #액자개수 3
reco_time = int(input()) #추천횟수  9
stu_li = list(map(int,input().split()))  #학생의 추천리스트 [2,1,4,3,5,6,2,7,2]
frame = list() 
count_num = [0]*frame_num   #기존 액자의 추천수 [0,0,0]

for i in range(reco_time):
    if len(frame) < frame_num and stu_li[i] not in frame:   # 1. 액자가 꽉차지않고 없는 추천이 들어올 경우
        frame.append(stu_li[i])         # 액자에 추천번호 추가 
        pos = frame.index(stu_li[i])    # 추천번호의 위치
        count_num[pos] += 1             # 그 위치의 추천수 +1
    
    elif stu_li[i] in frame:    # 2. 기존 액자에 있는 추천번호가 들어올 경우
        pos = frame.index(stu_li[i])
        count_num[pos] += 1     # 추천수 +1
    
    else:                       # 3. 새로운 추천이 들어올 경우
        frame.pop(min_idx(count_num))   # 추천수가 가장 작은 자리의 액자를 뽑아냄
        count_num.pop(min_idx(count_num))   # 추천수도 뽑아내기
        frame.append(stu_li[i])     # 새로 넣기
        count_num.append(1)
    # print(frame , count_num)

for j in sorted(frame):
    print(j, end=' ')
```



### 느낀점  

- update 쓰려고 했는데 보니깐 원소를 여러개 추가할때 update를 쓴다  ex) s1.update([4,5,6])
- replace쓰려고 햇는데 생각해보니깐 그러면 최소가 여러개면 다바뀜
- 지금까지의 코딩을 통틀어 역대급 뻘짓했다.    명세서 꼭 자세히 보자  **!!!!!!!!!!!!!!!
- 딕셔너리를 처음에 생각했었는데 일단 푸는게 먼저라 사용하지 못했다. 다음엔 쓰도록 하겠다.
- 좀 지쳣던 문제 ㅠㅠ