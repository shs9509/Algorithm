# 부호 [1247]

백준 - https://www.acmicpc.net/problem/1247



### 문제

-  N개의 정수가 주어지면, 이 정수들의 합 S의 부호를 구하는 프로그램을 작성하시오.



### 입력

- 총 3개의 테스트 셋이 주어진다. 
- 각 테스트 셋의 첫째 줄에는 N(1≤N≤100,000)이 주어진다.
- 둘째 줄부터 N개의 줄에 걸쳐 각 정수가 주어진다. 
- 주어지는 정수의 절댓값은 9223372036854775807보다 작거나 같다.



### 출력

- 총 3개의 줄에 걸쳐 각 테스트 셋에 대해 N개의 정수들의 합 S의 부호를 출력한다. 

  - S=0이면 "0"을, S>0이면 "+"를, S<0이면 "-"를 출력하면 된다.

- 예시

  ![image-20210130232728389](C:\Users\ssej0\Desktop\image-20210130232728389.png)



## 풀이과정



- 빈리스트에 케이스 값을 넣어서 리스트의  `sum` 을 통해서 합을 구한다,
- 합의 부호를 판별하고 정답 리스트에 `.append()` 한다.
- `sum` 을 이용했던 리스트는 다음 케이스를 위해 `.clear()`  해준다.



```python
answer = list()	#답을 넣을 리스트
num=list()	#연산할 숫자를 넣는 리스트

for i in range(3):	#케이스가 3개이므로 3번 돌린다.
    count=input()
    for i in range(int(count)):
        num.append(int(input()))	#input를 처음엔 count, 그다음 count 만큼 값을 받는다.
    if sum(num)>0:	#sum을 통해서 리스트의 부호판별
        answer.append('+')
    elif sum(num)==0:
        answer.append('0')
    else:
        answer.append('-')    
    num.clear()	#한번 연산을 끝내고 다음 리스트의 연산을 위해 clear한다.             

for i in range(3):
    print(answer[i])	#지금까지 연산한 값을 출력 
```



### 느낀점

- 처음 알고리즘을 풀어보다보니 입력값을 받을 당시 input 을 많이 생각하게 되었다. 

  - input의 값을 받는 방식에따라 문제풀이에도 변경이되서 고민 
  - 3개의 케이스를 받기 때문에 range 를 통해서 해결하였다.

  

- 브론즈 3의 문제였는데 그렇게 어렵지 않고 기본적인 문제 같았다.